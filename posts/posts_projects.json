[
	{
		"filename": "2019-07-05-PortAudio Wrapper-projects.min.md",
		"date": "2019/07/05",
		"title": "PortAudio Wrapper",
		"description": "",
		"content": "# PortAudio Wrapper\r\n\r\nC++ wrapper for PortAudio\r\n\r\nProvides a simple interface to PortAudio's callback API for reading and writing to audio devices. \r\n\r\n---\r\n\r\n### Basic Example:\r\n\r\n    #include \"pa.h\"\r\n    #include \"math.h\"\r\n    #define TWO_PI 6.2831853\r\n\r\n    double phase = 0, step = TWO_PI*440/44100.0;\r\n\r\n    void paFunc(const float* in, float* out, long frames, void* data){    \r\n        // play a 440Hz sine tone\r\n        for(int i = 0; i < frames; i++ ){\r\n             *out++ = sin(phase)*0.5;\r\n             phase += step;\r\n         }\r\n    }\r\n\r\n    int main() {\r\n        // use default parameters, not passing any data\r\n        Pa a(paFunc, NULL);\r\n        // start stream\r\n        a.start(Pa::waitForKey);\r\n        return 0;\r\n    }\r\n    \r\n\r\n### Usage:\r\n\r\n**Requirements:**\r\n\r\nPortAudio can be obtained [here](http://www.portaudio.com/).\r\n\r\n\r\n**Initializing:**\r\n\r\nDefine a callback where audio processing will occur and pass it as the constructor's first argument. The callback can be a simplified type: \r\n    \r\n    void paCallback(const float* inputBuffer, float* ouputBuffer, long framesPerBuffer, void* userData){...}\r\n    \r\nor have the full signature specified by PortAudio  \r\n\r\n    int paCallback(const void* inputBuffer, void* outputBuffer, unsigned long framesPerBuffer, \r\n            const PaStreamCallbackTimeInfo* timeInfo, PaStreamCallbackFlags statusFlags, void* userData){...}\r\n            \r\nThe wrapper's constructor can either take 2 arguments:&nbsp; the callback and a pointer for passing user data (see passing data):\r\n\r\n`Pa a(callback, &data);` \r\n\r\nor 6 arguments: &nbsp;callback, input channels, output channels, sampling rate, frames per buffer (0 will autoselect), userData:\r\n\r\n`Pa a(callback, 2, 2, 44100, 256, &data);`\r\n    \r\nThe 2-argument constructor is equivalent to: \r\n\r\n`Pa a(callback, 0, 1, 44100, 0, &data);` \r\n\r\n<br>\r\n\r\n**Starting / stopping the audio stream:**\r\n\r\nCalling `start()` will start the stream.\r\n\r\nFor convenience, there are four  enum values that can be passed  to `start()` to control the lifetime of the stream:\r\n\r\n- `Pa::dontTerminate` &nbsp;(_default_) Starts the stream only. &nbsp;Will stop if `stop()` is called, or the program exits.\r\n\r\n- `Pa::wait` &nbsp;Keeps the stream alive in a while loop, can be stopped from another thread.\r\n- `Pa::sleep`&nbsp; Keeps the stream alive for a specified number of milliseconds and then stops the stream. `setSleepTime(millis)` can be called to set the time, or a time in milliseconds can be passed directly i.e `start(5000)`\r\n- `Pa::waitForKey` &nbsp;Keeps the stream alive until a key is entered and then stops the stream.\r\n\r\n`stop()` &nbsp;stops the stream. &nbsp;`stop(true)` &nbsp;also closes the stream, which frees some additional resources.\r\n\r\nPortAudio will be terminated when the wrapper object is destroyed, but can be explicitly terminated by calling `terminate()`\r\n\r\n<br>\r\n\r\n**Passing data:**\r\n\r\nPortAudio allows for user data  to be passed to the audio callback. This can be omitted in favor of global variables. NULL can be passed for the user data parameter in this case.\r\n\r\nTo pass data to the callback, pass a data pointer to the constructor, and recast the data argument in your callback to your data type. For example:\r\n\r\n    void paFunc(const float* in, float* out, long frames, void* data){    \r\n        Osc* o = (Osc*)data;\r\n        for(long i = 0; i < frames; i++ ){\r\n             *out++ = o->out();\r\n         }\r\n    }\r\n        \r\n    Osc osc(440);\r\n    Pa a(paFunc, &osc);\r\n\r\n\r\nPortAudio provides the option to register a callback that will be called when a stream has stopped playing which takes the user data as an argument. This can be used to delete dynamically allocated data, and can be set with `setFinishedCallBack()`.  \r\nAn example  might look like:\r\n\r\n    void streamFinished(void* data){\r\n        Osc* o = (Osc*)data;\r\n        delete o;\r\n    }\r\n\r\n    int main() {\r\n        Osc* osc = new Osc(440);\r\n        Pa a(paFunc, osc);\r\n        a.setFinishedCallBack(streamFinished);\r\n        a.start(Pa::waitForKey);\r\n        return 0;\r\n    }\r\n    \r\nAlternatively, you can pass the data as a shared_ptr, which will delete resources automatically:\r\n\r\n    Osc* osc = new Osc(440);\r\n    Pa a(paFunc, std::shared_ptr<Osc>(osc));\r\n\r\n<br>\r\n\r\n**Querying / setting audio devices:**\r\n\r\n`listDevices()` prints a list of available input and output devices, sorted by device ID. \r\n\r\nTo set an input or output device, enter a device ID with `setInputDevice(ID)` or `setOutputDevice(ID)` respectively. \r\n\r\n`getDeviceInfo(ID)` prints additional information about a device. \r\n\r\n---\r\n### Reference:\r\n\r\n**Constructors**\r\n\r\n`Pa(callBack, userData)` &nbsp;\r\n\r\n`Pa(callBack, inChannels, outChannels, SampleRate, FramesPerBuffer, userData)`\r\n\r\n**Functions**\r\n\r\n`void start()`\r\n\r\n`void start(RunMode mode)`\r\n\r\n`void start(unsigned long sleepTime)`\r\n    \r\n`void stop()`\r\n\r\n`void stop(bool close)`\r\n\r\n`void terminate()`\r\n\r\n`void setSleepTime(unsigned long time)`\r\n\r\n`void setSampleFormat(PaSampleFormat format)`\r\n\r\n`void setFinishedCallBack(void(*callback)(void* data))`\r\n\r\n`void listDevices()`\r\n\r\n`void getDeviceInfo(unsigned int index)`\r\n\r\n`void setInputDevice(unsigned int index)`\r\n\r\n`void setOutputDevice(unsigned int index)`\r\n\r\n**Typedefs**\r\n\r\n`void miniCallBack(const float*, float*, long, void*)`\r\n\r\n`int mainCallBack(const void*, void*, unsigned long, const PaStreamCallbackTimeInfo*, PaStreamCallbackFlags, void*)`\r\n\r\n**Enums**\r\n\r\n`RunMode {dontTerminate, wait, sleep, waitForKey}`\r\n    ",
		"group": "projects",
		"categories": [],
		"display": true,
		"minimize": true,
		"static": false
	},
	{
		"filename": "2019-05-05-soundlib-projects.min.md",
		"date": "2019/05/05",
		"title": "soundlib",
		"description": "",
		"content": "#### SoundLib\r\n\r\nThis project is the start of what is to be an audio programming environment. SoundLib is just a working title, currently it's a library of objects for dsp and control.\r\n\r\n***\r\n\r\nThe main audio base-class **Sig** should provide everything needed to incorporate classes from other libraries like Stk or Maximilian:\r\n\r\n**variables:** \r\n```float* inputs[num_inlets]``` (default is 64)\r\n```float* input``` (same as inputs[0])\r\n```float output```\r\n```float val``` provided to store 1 intial value\r\n\r\n**Functions:**\r\n\r\n**-init:**\r\n```void init(uint _inlets = 1, bool _summing = auto_summing)``` sets number of active inlets, toggles summing\r\n-Each inlet is itself a summing-bus with a max of 64 parralel inputs.\r\n-This can be overriden in which case each inlet is mapped directly to the summing input, \r\n-otherwise each of the 64 inlets ```inputs[...]``` is mapped to a summing output.\r\n```void initVal(float* val, int inlet)``` points an inlet to any existing float\r\n```void setVal(float f, int inlet = 1)``` assigns a value to val and points an inlet to it\r\n\r\n**-constructors:**\r\n```Sig(double val = 0)``` (truncates to float)\r\n```Sig(uint inlets, bool summing)``` construct with n inlets, summing\r\n\r\n**-dsp:**\r\n```virtual void dsp()``` this is where a child class should implement it's dsp routine\r\n```virtual float out()``` these can be implemented to add dsp called by the user instead of being iniked by the library\r\n```virtual float out(double in)```\r\n\r\n**-connecting:**\r\n```void connect(Sig* child, uint inlet = 0)``` adds a child object to the Sig graph, disconnecting it from the root node, and connect's a's output to b's input at a specified inlet.\r\n```void disconnect(Sig* child, uint inlet = 0)``` disconnects, and will reconnect b to the root node if neccesary.\r\n\r\nThese call external ```sig_connect```/```sig_disconect``` functions which also include \r\n```sig_connect(float* a, Sig* b, uint inlet = 0)``` which will connect (or remove) any float* to an inlet \r\n\r\n**-others:**\r\n```void Call()``` this is calls dsp() and sumInputs() if summing, and is called by the dsp scheduler\r\n```virtual void bypass_summing(uint inlet = 0)``` this called by Connect/disconnect\r\n```void sumInputs()```\r\n\r\nHere is an example:\r\n\r\n\t// 2-inlet sum (like +~ in PD)\r\n   \tclass Sum : public Sig{\r\n    public:\r\n        Sum(double f = 0){\r\n            init(2); // 2 inlets\r\n            setVal(f, 1); // set default val to right inlet\r\n        }\r\n        \r\n        void dsp(){ \r\n            output = *inputs[0];\r\n            output += *inputs[1];\r\n        }\r\n    };\r\n\r\n***\r\n\r\nthe base class for control objects is **Ctl**. Control messages have a simple structure currently and all message sources are polling to generate messages, Events and a different message protocol of some kind will be incorporated. \r\n\r\nThe Msg struct has an int for number of Vals, a type field, an index that can be set by the caller, and an array of n Vals. Val is a union that can take on float int or note struct types. Depending on how parameters are parsed and from protocols like midi, osc or fudi this will likely change.\r\n\r\nCtl provides a member Msg, and the following functions:\r\n\r\n```virtual void run(Msg _m){}``` this is the control equivalent of dsp() in Sig.\r\n\r\n```virtual void run(){}```\r\n\r\n```virtual void onConnect(Ctl* child){}``` \r\n\r\n```void msg_alloc(size_t num)``` this must be called to allocate the contents of a message\r\n\r\n```void copy_msg(Msg _m)``` copy the contents of an incoming message\r\n\r\n***\r\n\r\nSig objects are in soundlib_sig.h and expr.h, which is an audio expression parser like pd's expr~ with the variables f0-f63 corresponding to it's inlets. Ctl objects are in soundlib_ctl.h.",
		"group": "projects",
		"categories": [],
		"display": true,
		"minimize": true,
		"static": false
	}
]