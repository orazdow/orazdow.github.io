[
	{
		"filename": "2019-07-25-small-main.md",
		"date": "2019-07-25",
		"title": "small",
		"description": "",
		"content": "# this is a small post\r\n\r\nsfsdfsdf\r\n\r\n\r\n7/30/2019",
		"group": "main",
		"categories": [],
		"display": true,
		"minimize": false,
		"static": false
	},
	{
		"filename": "2019-05-06-PortAudio Wrapper-main.md",
		"date": "2019-05-06",
		"title": "PortAudio Wrapper",
		"description": "",
		"content": "# PortAudio Wrapper\r\n\r\nC++ wrapper for PortAudio\r\n\r\nProvides a simple interface to PortAudio's callback API for reading and writing to audio devices. \r\n\r\n---\r\n\r\n### Basic Example:\r\n\r\n    #include \"pa.h\"\r\n    #include \"math.h\"\r\n    #define TWO_PI 6.2831853\r\n\r\n    double phase = 0, step = TWO_PI*440/44100.0;\r\n\r\n    void paFunc(const float* in, float* out, long frames, void* data){    \r\n        // play a 440Hz sine tone\r\n        for(int i = 0; i < frames; i++ ){\r\n             *out++ = sin(phase)*0.5;\r\n             phase += step;\r\n         }\r\n    }\r\n\r\n    int main() {\r\n        // use default parameters, not passing any data\r\n        Pa a(paFunc, NULL);\r\n        // start stream\r\n        a.start(Pa::waitForKey);\r\n        return 0;\r\n    }\r\n    \r\n\r\n### Usage:\r\n\r\n**Requirements:**\r\n\r\nPortAudio can be obtained [here](http://www.portaudio.com/).\r\n\r\n\r\n**Initializing:**\r\n\r\nDefine a callback where audio processing will occur and pass it as the constructor's first argument. The callback can be a simplified type: \r\n    \r\n    void paCallback(const float* inputBuffer, float* ouputBuffer, long framesPerBuffer, void* userData){...}\r\n    \r\nor have the full signature specified by PortAudio  \r\n\r\n    int paCallback(const void* inputBuffer, void* outputBuffer, unsigned long framesPerBuffer, \r\n            const PaStreamCallbackTimeInfo* timeInfo, PaStreamCallbackFlags statusFlags, void* userData){...}\r\n            \r\nThe wrapper's constructor can either take 2 arguments:&nbsp; the callback and a pointer for passing user data (see passing data):\r\n\r\n`Pa a(callback, &data);` \r\n\r\nor 6 arguments: &nbsp;callback, input channels, output channels, sampling rate, frames per buffer (0 will autoselect), userData:\r\n\r\n`Pa a(callback, 2, 2, 44100, 256, &data);`\r\n    \r\nThe 2-argument constructor is equivalent to: \r\n\r\n`Pa a(callback, 0, 1, 44100, 0, &data);` \r\n\r\n<br>\r\n\r\n**Starting / stopping the audio stream:**\r\n\r\nCalling `start()` will start the stream.\r\n\r\nFor convenience, there are four  enum values that can be passed  to `start()` to control the lifetime of the stream:\r\n\r\n- `Pa::dontTerminate` &nbsp;(_default_) Starts the stream only. &nbsp;Will stop if `stop()` is called, or the program exits.\r\n\r\n- `Pa::wait` &nbsp;Keeps the stream alive in a while loop, can be stopped from another thread.\r\n- `Pa::sleep`&nbsp; Keeps the stream alive for a specified number of milliseconds and then stops the stream. `setSleepTime(millis)` can be called to set the time, or a time in milliseconds can be passed directly i.e `start(5000)`\r\n- `Pa::waitForKey` &nbsp;Keeps the stream alive until a key is entered and then stops the stream.\r\n\r\n`stop()` &nbsp;stops the stream. &nbsp;`stop(true)` &nbsp;also closes the stream, which frees some additional resources.\r\n\r\nPortAudio will be terminated when the wrapper object is destroyed, but can be explicitly terminated by calling `terminate()`\r\n\r\n<br>\r\n\r\n**Passing data:**\r\n\r\nPortAudio allows for user data  to be passed to the audio callback. This can be omitted in favor of global variables. NULL can be passed for the user data parameter in this case.\r\n\r\nTo pass data to the callback, pass a data pointer to the constructor, and recast the data argument in your callback to your data type. For example:\r\n\r\n    void paFunc(const float* in, float* out, long frames, void* data){    \r\n        Osc* o = (Osc*)data;\r\n        for(long i = 0; i < frames; i++ ){\r\n             *out++ = o->out();\r\n         }\r\n    }\r\n        \r\n    Osc osc(440);\r\n    Pa a(paFunc, &osc);\r\n\r\n\r\nPortAudio provides the option to register a callback that will be called when a stream has stopped playing which takes the user data as an argument. This can be used to delete dynamically allocated data, and can be set with `setFinishedCallBack()`.  \r\nAn example  might look like:\r\n\r\n    void streamFinished(void* data){\r\n        Osc* o = (Osc*)data;\r\n        delete o;\r\n    }\r\n\r\n    int main() {\r\n        Osc* osc = new Osc(440);\r\n        Pa a(paFunc, osc);\r\n        a.setFinishedCallBack(streamFinished);\r\n        a.start(Pa::waitForKey);\r\n        return 0;\r\n    }\r\n    \r\nAlternatively, you can pass the data as a shared_ptr, which will delete resources automatically:\r\n\r\n    Osc* osc = new Osc(440);\r\n    Pa a(paFunc, std::shared_ptr<Osc>(osc));\r\n\r\n<br>\r\n\r\n**Querying / setting audio devices:**\r\n\r\n`listDevices()` prints a list of available input and output devices, sorted by device ID. \r\n\r\nTo set an input or output device, enter a device ID with `setInputDevice(ID)` or `setOutputDevice(ID)` respectively. \r\n\r\n`getDeviceInfo(ID)` prints additional information about a device. \r\n\r\n---\r\n### Reference:\r\n\r\n**Constructors**\r\n\r\n`Pa(callBack, userData)` &nbsp;\r\n\r\n`Pa(callBack, inChannels, outChannels, SampleRate, FramesPerBuffer, userData)`\r\n\r\n**Functions**\r\n\r\n`void start()`\r\n\r\n`void start(RunMode mode)`\r\n\r\n`void start(unsigned long sleepTime)`\r\n    \r\n`void stop()`\r\n\r\n`void stop(bool close)`\r\n\r\n`void terminate()`\r\n\r\n`void setSleepTime(unsigned long time)`\r\n\r\n`void setSampleFormat(PaSampleFormat format)`\r\n\r\n`void setFinishedCallBack(void(*callback)(void* data))`\r\n\r\n`void listDevices()`\r\n\r\n`void getDeviceInfo(unsigned int index)`\r\n\r\n`void setInputDevice(unsigned int index)`\r\n\r\n`void setOutputDevice(unsigned int index)`\r\n\r\n**Typedefs**\r\n\r\n`void miniCallBack(const float*, float*, long, void*)`\r\n\r\n`int mainCallBack(const void*, void*, unsigned long, const PaStreamCallbackTimeInfo*, PaStreamCallbackFlags, void*)`\r\n\r\n**Enums**\r\n\r\n`RunMode {dontTerminate, wait, sleep, waitForKey}`\r\n    ",
		"group": "main",
		"categories": [],
		"display": true,
		"minimize": false,
		"static": false
	}
]